package com.mycompany.myapp.service.impl;

import java.util.HashMap;
import java.util.Map;

public class 可实现价值Service {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

	}

	public static String 取得可实现价值信息_根据投资组号(String s投资组号) {
		// 可实现价值信息
		// 用你现在手头的资源，和最新的行情信息
		// 目的是为了取得【折算后的可实现股数】
		// 背景：取得成本股数的目的是，
		//      是为了与【成本股数】做对比
		//      被【收益Service.is有可实现利益()调用

		// 先取得 可利用资金数
		// 1、循环从自选股中依次取得股票代码
		//    1.1、取得【取得折算成本价by投资组号】
		//    1.2、取得可取得的股票数
		//    1.3、判断是否最多
		//        （1）如果最多、就确定返回可实现筹码数
		// 循环1结束
		float f最高可取得的股票数 = 0;
		String f可利用资金数 = 交易策略Service.取得当前可利用现金数(s投资组号);
		for( Map 自选股Map:交易策略Service.自选股List) {
			String s折算成本价 = 交易策略Service.取得折算成本价by投资组号(s投资组号);
			float f可取得的股票数 = Float.parseFloat(f可利用资金数) / Float.parseFloat(s折算成本价);
			if(f可取得的股票数 > f最高可取得的股票数) {
				f最高可取得的股票数 = f可取得的股票数;
			}
		}
		return f最高可取得的股票数 + "";
	}

	/**
	 *
	 * @param s投资组号
	 * @return
	 */
	public static Map 取得实操作信息Map(String s投资组号) {
		// 要买的股票一定是从【可实现价值Service】中取得（股票代码，数量，价格）
		// 这个有一点复杂：
		// 就是待选股票会有很多，并不是唯一的，要从中找到一个最合适的
		// 最合适的意义：
		// 在于，经过折算之后，这个股票可以实现更多的筹码。

		// 1、先在【自选股】里找到候选股票
		// 2、遍历每一只股票，取得最新成交价格
		//    2.1、取得【折算后最低的股价】
		//         例，折算价是5块
		//         A股
		Map 折算后最低的股价Map = new HashMap();
		float 折算后最低的股价 = 0;
		String 折算后最低的股票代码 = null;
		for( Map 自选股票map : 交易策略Service.自选股List ) {

			String s最新成交价格 = 实时行情Service.取得最新成交价格_by股票代码((String)自选股票map.get("股票代码"), (String)自选股票map.get("市场代码"));
			float 当前折算后的股价 = Float.parseFloat(实时行情Service.取得折算后的股价(s最新成交价格, 自选股票map, s投资组号));
			if(0 == 折算后最低的股价) {

				折算后最低的股价 = 当前折算后的股价;
				折算后最低的股票代码 = (String) 自选股票map.get("股票代码");

			}else if(当前折算后的股价 < 折算后最低的股价) {

				折算后最低的股价 = 当前折算后的股价;
				折算后最低的股票代码 = (String) 自选股票map.get("股票代码");
			}

		}
		折算后最低的股价Map.put("买入股票代码", 折算后最低的股票代码 + "");
		折算后最低的股价Map.put("折算后的股价", 折算后最低的股价 + "");
		String 可购入筹码数量 = 交易策略Service.取得可购入筹码数量(s投资组号, 折算后最低的股票代码);
		折算后最低的股价Map.put("可购入筹码数量", 可购入筹码数量);
		折算后最低的股价Map.put("最高购入单价", 折算后最低的股价);
		String 在库折算后筹码数量 = 交易策略Service.取得在库折算后筹码数量(s投资组号);
		折算后最低的股价Map.put("可实现盈余筹码", 交易策略Service.取得可实现盈余筹码数量(可购入筹码数量, 在库折算后筹码数量));
		return 折算后最低的股价Map;
	}

	/**
	 *
	 * @param 买一到买五的数量与价格
	 * @param 在库筹码信息
	 * @param 未实现筹码信息    也有可能当前的信息
	 * @return
	 */
	static String 取得可实现的资金数by买一到买五的信息(Map 买一到买五的数量与价格, Map<String, String> 在库筹码信息, String 未实现筹码信息) {
		// 你的筹码，在此时如何变成现金？
		// 从买1到5，一共有5档，按5档的价格从高到低，依次卖出即可
		// 取得买1的价格与筹码
		float 可实现的资金数=0;
		未实现筹码信息 = 在库筹码信息.get("筹码数量");

		String s买1的价格 = (String) 买一到买五的数量与价格.get("买1的价格");
		String s买1的数量 = (String) 买一到买五的数量与价格.get("买1的数量");
		可实现的资金数 += 取得可实现的资金数by价格数量(s买1的价格,s买1的数量,未实现筹码信息);

		if(!未实现筹码信息.equals("0")) {
			String s买2的价格 = (String) 买一到买五的数量与价格.get("买2的价格");
			String s买2的数量 = (String) 买一到买五的数量与价格.get("买2的数量");
			可实现的资金数 += 取得可实现的资金数by价格数量(s买2的价格,s买2的数量,未实现筹码信息);
		}
		if(!未实现筹码信息.equals("0")) {
			String s买3的价格 = (String) 买一到买五的数量与价格.get("买3的价格");
			String s买3的数量 = (String) 买一到买五的数量与价格.get("买3的数量");
			可实现的资金数 += 取得可实现的资金数by价格数量(s买3的价格,s买3的数量,未实现筹码信息);
		}
		if(!未实现筹码信息.equals("0")) {
			String s买4的价格 = (String) 买一到买五的数量与价格.get("买4的价格");
			String s买4的数量 = (String) 买一到买五的数量与价格.get("买4的数量");
			可实现的资金数 += 取得可实现的资金数by价格数量(s买4的价格,s买4的数量,未实现筹码信息);
		}
		if(!未实现筹码信息.equals("0")) {
			String s买5的价格 = (String) 买一到买五的数量与价格.get("买5的价格");
			String s买5的数量 = (String) 买一到买五的数量与价格.get("买5的数量");
			可实现的资金数 += 取得可实现的资金数by价格数量(s买5的价格,s买5的数量,未实现筹码信息);
		}
		在库筹码信息.put("筹码数量", 未实现筹码信息);
		return 可实现的资金数 + "";
	}

	/**
	 *
	 * @param s买1的价格
	 * @param s买1的数量
	 * @param 未实现筹码信息
	 * @return
	 */
	private static float 取得可实现的资金数by价格数量(String s买1的价格, String s买1的数量, String 未实现筹码信息) {
		// 1、如果 s买1的数量 大于等于 未实现筹码信息
		//     1.1 就用 未实现筹码信息 来计算
		//	   1.2 未实现筹码信息 置为零
		// 2、如果 s买1的数量 小于 未实现筹码信息
		//	   2.1 就用 未实现筹码信息 来计算
		//	   2.2 未实现筹码信息 置为 未实现筹码信息-s买1的数量

		float f可实现的资金数=0;
		long l未实现筹码信息 = Long.parseLong(未实现筹码信息);
		long l买1的数量 = Long.parseLong(s买1的数量);
		float f买1的价格 = Float.parseFloat(s买1的价格);

		// 1、如果 s买1的数量 大于等于 未实现筹码信息
		//     1.1 就用 未实现筹码信息 来计算
		//	   1.2 未实现筹码信息 置为零
		if(l买1的数量 >= l未实现筹码信息) {

			f可实现的资金数 = l未实现筹码信息 * f买1的价格;
			l未实现筹码信息 = 0;
		}

		// 2、如果 s买1的数量 小于 未实现筹码信息
		//	   2.1 就用 未实现筹码信息 来计算
		//	   2.2 未实现筹码信息 置为 未实现筹码信息-s买1的数量
		else if(l买1的数量 < l未实现筹码信息) {

			f可实现的资金数 = l买1的数量 * f买1的价格;
			l未实现筹码信息 -= l买1的数量;
		}
		未实现筹码信息 = l未实现筹码信息 + "";
		return f可实现的资金数;
	}

	/**
	 *
	 * @param 卖一到卖五的数量与价格
	 * @param 当前可利用现金
	 * @param 未利用现金
	 * @return
	 */
	public static String 取得可购入筹码数量by买一到买五的信息(Map 卖一到卖五的数量与价格, String s当前可利用现金, String s未利用现金) {
		// 用现金能买到多少的筹码数呢
		// 从卖1到5，一共有5档，按5档的价格从低到高，依次买入即可

		// 取得买1的价格与筹码
		long f可购入筹码数量=0;
		float f未利用现金 = Float.parseFloat(s未利用现金);
		s未利用现金 = s当前可利用现金+"";

		String s买1的价格 = (String) 卖一到卖五的数量与价格.get("买1的价格");
		String s买1的数量 = (String) 卖一到卖五的数量与价格.get("买1的数量");
		f可购入筹码数量 += 取得可实现的资金数by价格数量(s买1的价格,s买1的数量, s未利用现金);

		if(!s未利用现金.equals("0")) {
			String s买2的价格 = (String) 卖一到卖五的数量与价格.get("买2的价格");
			String s买2的数量 = (String) 卖一到卖五的数量与价格.get("买2的数量");
			f可购入筹码数量 += 取得可实现的资金数by价格数量(s买2的价格,s买2的数量, s未利用现金);
		}
		if(!s未利用现金.equals("0")) {
			String s买3的价格 = (String) 卖一到卖五的数量与价格.get("买3的价格");
			String s买3的数量 = (String) 卖一到卖五的数量与价格.get("买3的数量");
			f可购入筹码数量 += 取得可实现的资金数by价格数量(s买3的价格,s买3的数量, s未利用现金);
		}
		if(!s未利用现金.equals("0")) {
			String s买4的价格 = (String) 卖一到卖五的数量与价格.get("买4的价格");
			String s买4的数量 = (String) 卖一到卖五的数量与价格.get("买4的数量");
			f可购入筹码数量 += 取得可实现的资金数by价格数量(s买4的价格,s买4的数量, s未利用现金);
		}
		if(!s未利用现金.equals("0")) {
			String s买5的价格 = (String) 卖一到卖五的数量与价格.get("买5的价格");
			String s买5的数量 = (String) 卖一到卖五的数量与价格.get("买5的数量");
			f可购入筹码数量 += 取得可实现的资金数by价格数量(s买5的价格,s买5的数量, s未利用现金);
		}

		return f可购入筹码数量 + "";

	}

}
